aop流程1：
	1.找到目标对象	要做什么
	2.抽取横切关注点
	3.把它封装到一个切面中
	4.把每一个横切关注点写成一个通知

aop流程2：
	从目标对象中把非核心业务代码抽取出来->非核心业务代码：横切关注点
	把横切关注点放在一个类中->类：切面
	每一个横切关注点都写成一个方法->方法：通知
	把功能套回到目标对象连接点
	切入点定位连接点

横切关注点
	从目标对象中抽取出的非核心业务
通知
	把横切关注点收集（封装）到一个类中
	此类叫切面
	封装的每一个横切关注点都是一个通知（通知方法）

	前置通知：目标对象方法执行之前 要执行的内容
	返回通知：在目标对象返回值之后 执行的内容(有异常时没有返回值,不执行此通知)
	异常通知：目标对象方法出现异常时执行的内容   在目标对象catch中执行
	后置通知：目标对象执行方法中的finally 执行的内容
	环绕通知：使用try catch finally结构围绕整个目标对象的方法
	1环绕通知=前置通知+返回通知+异常通知+后置通知
切面
	封装通知方法（横切关注点）的类
目标
	被代理的目标对象
代理
	为目标对象创建出的代理对象（不需要手动创建，由aop创建）
连接点
	抽取横切关注点的位置  横切关注点被抽取出来后最终要被套回连接点（纯逻辑概念）
切入点
	定位连接点的方式（是一条表达式）
代码增强：
	在不改变源代码的基础上，将切面套到目标对象的方法执行过程中


AspectJ:
	aop思想的实现
	本质上是静态代理，将代理逻辑织入（weaver织入器）被代理的目标类 编译得到的字节码文件中，最终效果是动态的。
	Spring只是借用了AspectJ中的注解