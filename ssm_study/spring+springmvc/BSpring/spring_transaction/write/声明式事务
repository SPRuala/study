编程式事务
    要实现事务的功能,就需要自己编写实现事务的代码
    缺点:所有的细节需要程序员自己编写,繁琐
        代码复用性不高

声明式事务
    声明式=>框架=>只需要配置,就可以实现功能,具体实现功能的过程由框架来完成
    优点:
        提高开发效率
        消除冗余代码
        健壮性、性能优化(spring进行事务管理的同时设置了事务相关属性：只读、超时时间、回滚策略..)
    事务控制的代码大多内容重复,框架可以将固定模式的代码抽取出来进行封装(类似于手写aop)
    声明式事务不需要手写事务切面和事务管理的通知,框架已经封装完成,程序员只需要把切面中事务管理的通知定位到连接点即可。
    封装完成后,进行简单的配置即可完成操作。

    (以下使用配置文件为:tx-annotation.xml=>基于注解的声明式事务)
    声明式事务需要在执行sql语句中被测试.
        场景(用户买书):
            具体操作:查购买图书价格=>更新图书库存=>更新用户余额
            使抛出问题(异常):模拟余额不够的情况,测试声明式事务=>业务逻辑异常(余额<0,不会报错),需要回滚。
            回滚:在程序报错时可以进行回滚。
            制造错误:余额不够
            解决:1.数据库层面解决
                    字段设置关键字unsigned(无符号),最小值会从0开始,最大值也会发生变化
                    此时如果余额不够,将从MySQL层面抛出异常
                2.Java代码层面解决
                    更新时判断余额、库存是否充足？ 充足执行更新,不足手动抛出运行时异常(throw new RuntimeException)

    实现过程:
        1.创建组件(Controller、Service、Dao)
        2.配置文件添加组件扫描
        3.配置事务管理器
        4.开启事务注解驱动
        5.添加注解
    无事务场景:每个sql语句独占一个事务且自动提交(mybatis),因此一个sql语句出问题不会影响到另一个
    声明式事务场景:利用bug回滚。如果有一个sql语句出现异常,就把整个事务都回滚。(达成要么都成功,要么都失败的情况)

事务属性
    只读:
        readOnly=true   默认false
        如果事务中都是查询操作,只读属性可以告诉数据库该事务中没有写操作。此时可从数据库层面优化当前操作。
    超时:
        timeout = 3     3:超时三秒强制回滚
        事务在执行过程中发生各种问题,导致事务长时间没有执行完。此时可以通过超时属性设置超时时间,规定时间内没执行完强制回滚,并抛出异常
    回滚策略:
        rollbackForClassName:value为异常的全类名。因为什么而回滚
        rollbackFor:value为异常所对应的class对象。因为什么而回滚
        noRollbackFor:value为异常所对应的class对象。不因什么而回滚。当因为该bug报错时不回滚。
        noRollbackForClassName:value为异常的全类名。不因什么而回滚
        默认回滚策略为:运行时只要发生任何异常,回滚整个事务
        声明式事务针对所有运行时异常默认回滚,一般情况可能下会设置noRollbackFor和noRollbackForClassName
    事务的隔离级别:
        isolation(枚举)
        默认隔离级别:可重复读
        一般情况下为.DEFAULT(当前所用数据库中默认的隔离级别)
        每下一级隔离级别,都解决了上一级的问题
        读未提交(READ UNCOMMITTED):事务A可以读取事务B尚未提交的修改。 问题:若B未提交数据进行回滚,则A读出的数据无意义(脏读)。
        读已提交(READ COMMITTED):事务A只能读取事务B已经提交的数据。 问题:A读取出来的B尚未提交的数据和已经提交的数据不同(不可重复读)。
        可重复读(REPEATABLE READ):事务A在操作某条数据时,会将该数据加锁。B若想操作该数据,就会处于阻塞状态,直到A提交数据后,B才能继续处理。    问题:A操作某条数据时,B依然可以对其他数据进行操作。读出的结果依然不同。(幻读)(Mysql已避免)
        串行化(SERIALIZABLE):事务A在操作某个表时,将该表加锁。B若想操作该表,就会处于阻塞状态,直到A提交数据后,B才能继续处理。可以避免任何并发问题。  问题:性能非常低。
    事务的传播行为:
        propagation=
        两个有事务功能的方法A、B,在A中调用B方法。故B中有两个事务可以被选择使用(A的事务、B本身的事务)
        若选择B本身事务(默认):将方法A看作每个操作,B看作整个事务。若有一个A操作未成功执行,回滚整个B事务。
        若选择A事务:将方法A的每个操作单看成一个事务。若有一个A操作未成功执行,只回滚当前操作。
        若切换成使用A的事务,需在A注解中添加属性propagation = Propagation.REQUIRES_NEW(不使用B的事务,在执行B时开启一个新的事务=>使用A的事务)